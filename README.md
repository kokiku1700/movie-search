# 영화 및 TV시리즈 검색 서비스

## 프로젝트 소개
본 프로젝트는 TMDB api를 활용한 검색 서비스다. 

키워드 검색, 작품 상세 정보, 페이지네이션, 로그인 기반 좋아요 기능을 제공하고 있다. 

**Next.js**와 **Tailwind css**, **PostgreSQL**를 실제 서비스에 처음 적용해보는 프로젝트로 각 기술의 기본 개념과 숙달을 목표로 진행했다. 

특히 next.js의 장점인 **SEO 노출 최적화**, **빠른 렌더링**, **백엔드 기능 지원**의 특성을 고려해 검색 중심 서비스에 적합한 구조를 설계하기 위해 해당 주제를 선택하게 됐다. 

## 배포 링크
<http://movie-search-delta-one.vercel.app>

*TMDB api를 활용한 영화 및 TV시리즈 검색 서비스다.*

*키워드 기반으로 검색을 제공하며, 로그인 시 좋아요 기능을 사용할 수 있다.* 
## 주요 기능

### 키워드 검색
영화 및 TV시리즈를 키워드로 검색할 수 있다.

TMDB api를 활용한 실시간 검색 결과를 제공한다.

*검색어를 URL 쿼리 파라미터로 관리하여 새로고침이나 링크 공유에도 검색 결과가 유지되도록 만들었다.* 

![키워드 검색 결과 이미지("너의")](/public/readmeImg/keyword_search.png)

### 좋아요 
토글 방식을 활용해 좋아요 / 취소가 가능하다. 

좋아요한 작품은 좋아요 페이지에서 한 눈에 확인이 가능하다.

좋아요 누른 작품은 메인 페이지 및 검색 목록 페이지, 상세 페이지에도 일관되게 표시된다.

*좋아요는 서버에 저장되는 데이터이기 때문에 React Query를 활용해 구현했다.* 

*여러 페이지 간 이동 시에도 좋아요 상태가 즉시 동기화되도록 구현했다.*

![좋아요](/public/readmeImg/like.png)

### 상세 페이지
각 작품 포스터 클릭 시 상세 페이지를 이동할 수 있다.

해당 작품의 포스터, 제목, 출시일, 연령 제한, 카테고리, 상영시간, 평점, 좋아요 여부, 간단 줄거리, 감독, 출연진(애니메이션인 경우 성우), 트레일러(일부 작품 제외)등 작품에 대한 전반적인 정보를 제공하고 있다. 

*파라미터로 받은 작품의 'type'과 'id'를 기반으로 TMDB api에 요청해 상세 정보를 조회할 수 있다.*

*상세 정보에 있는 작품 제목을 metadata의 title에 적용해,*
*동적으로 페이지 별 제목이 노출되도록 설계했다.*

![상세 페이지1](/public/readmeImg/detail1.png)
![상세 페이지2](/public/readmeImg/detail2.png)

### 페이지네이션
많은 양의 검색 결과를 페이지 단위로 제공한다.

TMDB api에서 제공하는 페이지 번호를 활용해 페이지네이션의 번호를 구성했다.

*페이지 변경 시 검색어와 변경된 페이지 번호를 URL 쿼리 파라미터로 전달해 페이지를 이동해도 검색 결과를 유지하게 구현했다.*

![페이지네이션 이미지](/public/readmeImg/Pagination.png)

### 회원가입 및 로그인
좋아요 기능을 이용하기 위해 필요한 인증 기능이다. 

이번 프로젝트의 주 기능은 TMDB api를 불러와 작품 검색 및 저장이 목적이기에 회원가입과 로그인은 이용에 필요한 최소한의 기능 위주로 구현했다. 

사용자는 닉네임, 아이디, 패스워드를 사용해 회원가입이 가능하다. 

- 닉네임, 아이디는 blur 이벤트를 이용해 중복 검증으로 유일하게 관리된다.
- 패스워드는 중복이 가능하고 재확인 검증 로직으로 구현했다. 

회원가입 후 다음과 같은 기능을 제공한다.
- 닉네임 변경
- 비밀번호 변경
- 회원탈퇴

![회원가입](/public/readmeImg/signUp.png)
![로그인](/public/readmeImg/signIn.png)
직관적이며 검색, 목록, 상세 페이지의 흐름을 방해하지 않게 단순하게 설계했다. 

## 기술 스택

### **Framework**: Next.js
- App router, 서버 렌더링, 메타 데이터 기능을 실제 서비스에 적용해보기 위해 검색과 상세 페이지 중심의 구조를 가진 프로젝트를 설계했다. 
### **Language**: TypeScript
- 컴포넌트 props와 API 응답 데이터의 구조를 명확히 정의해, 런타임 오류를 줄이고 코드 안정성을 확보하기 위해 사용했다.
### **Server State**: React Query
- 메인, 검색, 상세 페이지에서 동일한 좋아요 상태를 일관되게 관리하고, 서버 상태와 UI 동기화를 안정적으로 처리하기 위해 사용했다.
### **Database**: PostgreSQL (Supabase)
- 회원 정보와 좋아요 데이터 간 관계를 직접 설계하고 SQL 기반의 데이터 처리 흐름을 경험해보기 위해 관계형 데이터베이스를 사용했다.
### **Style**: Tailwind CSS
- 기존에 사용했던 Styled Component와 차이점를 비교하며 유틸리티 기반 스타일링 방식의 장단점을 직접 경험해보기 위해 사용했다.
### **External API**: TMDB API
- 영화 및 TV 시리즈에 대한 방대한 데이터를 제공받아 검색 및 상세 페이지 기능을 구현하기 위한 데이터 소스로 활용했다.
### **Deployment**: Vercel
- Next.js와의 높은 호환성과 간단한 배포 환경을 활용해 빠른 배포 및 검증 사이클을 구축하기 위해 사용했다.

## 프로젝트 구조
app
- api - Route Handler(백엔드 API)
- page - 페이지 라우팅
- page.tsx - 메인 페이지

components - UI 컴포넌트

domains - 로그인 인증 규칙

hooks - React Query 및 상태 관리 훅(커스텀 훅)

lib - 외부 API, DB 공통 유틸

public - 이미지

## 핵심 구현

### React Query 기반 좋아요 상태 관리
- 좋아요 상태를 전역 캐시로 관리해 페이지 이동 시에도 일관되게 유지했다.

- 낙관적 업데이트를 적용해 사용자 입력에 즉시 반응하도록 UX를 개선했다.

### URL 쿼리스트링 기반 검색 및 페이지네이션 상태 설계
- 검색어와 페이지 번호를 URL로 관리해 새로고침, 공유, 뒤로가기 시에도 상태를 유지했다.

- 검색 중심 서비스에 적합한 접근성과 사용성을 확보했다.

### Next.js App Router 데이터 패칭 구조
- 렌더링 목적에 따라 서버/클라이언트 컴포넌트에서 TMDB 데이터 패칭을 분리해 사용했다.

## 트러블 슈팅

### React Query 기반 좋아요 반응 속도 개선

#### 문제 상황
배포 환경에서 좋아요 토글 시 평균 약 600ms의 응답 지연이 발생했고, 수치 상으로는 크지 않지만 체감상 1초 이상으로 느껴져 사용자 경험을 저해하는 문제를 확인했다.

#### 해결 방법
- 원인을 Vercel과 Supabase 간 물리적 거리로 인한 네트워크 지연으로 판단했고, 서버 응답을 기다리는 방식 대신 UX 개선을 위해 낙관적 업데이트(Optimistic Update)를 선택했다.

- 기존 mutationFn + onSuccess 구조를 onMutate 기반으로 변경하고, 실패 시 상태를 되돌리기 위해 onError를 함께 적용해 캐시를 즉시 업데이트하도록 구현했다.

#### 추가 문제
낙관적 업데이트 이후 비회원 상태에서 좋아요가 눌리는 현상이 발생했다. 

#### 해결 방법
onMutate에도 userId가 없을 경우 에러를 발생시켜 onError에 전달했다.

#### 결과
좋아요 반응 속도를 체감 기준으로 즉시 반영 수준으로 개선했으며 실제 반응 시간도 100ms 미만으로 단축하는데 성공했다.

### Next.js App Router에서 서버 컴포넌트와 클라이언트 컴포넌트 책임 충돌 문제

#### 문제
검색 목록 페이지는 쿼리 파라미터를 기반으로 TMDB 데이터를 서버에서 패칭하는 서버 컴포넌트였다. 

하지만 페이지 내부에 검색 결과 랜더링과 관련된 클라이언트 로직이 함께 포함되면서, 

서버 컴포넌트와 클라이언트 컴포넌트의 역할이 혼재되어 App Router 제약으로 인한 에러가 발생했다.

#### 해결 방법
서버 컴포넌트는 검색어를 받아 데이터를 패칭하는 역할만 담당하도록 제한하고, 검색 결과 랜더링 영역은 별도의 컴포넌트로 분리했다.

또한 TMDB API 호출 로직을 유틸 함수로 분리해 페이지 컴포넌트의 책임을 명확히 했다.

#### 결과
서버와 클라이언트 컴포넌트 간의 구조적 충돌을 해결했으며,

검색 목록 페이지의 코드 가독성과 구조적 명확성을 개선할 수 있었다.

### 배포 환경에서만 API가 실패

#### 문제
로컬 환경에서는 잘 호출되던 TMDB API가 배포 환경에서만 응답하지 않아 페이지가 렌더링되지 않는 문제가 발생했다.

#### 원인
로컬에서는 .env.local 파일을 통해 환경 변수가 자동으로 주입되지만,

Vercel 배포 환경에서는 별도로 환경 변수를 등록해야 한다는 점을 인지하지 못했다.

#### 해결 방법
Vercel Project Settings에 TMDB API 관련 환경 변수를 집접 등록한 뒤 재배포를 진행했다.

#### 결과 
배포 환경에서도 TMDB API가 정상적으로 호출되며 페이지가 정상 렌더링되는 것을 확인했다.

### 배포 환경에서 DB 연결 실패

#### 문제
배포 후 로그인 혹은 회원가입시 DB 연결에 실패했다는 에러 메세지가 발생했다. 

#### 원인
배포 환경에서 localhost:5432 기반의 로컬 DB는 접근할 수 없으며, 

Vercel의 서버리스 환경에서는 요청마다 함수가 실행되기 때문에 전통적인 방식의 DB 커넥션 관리가 어렵다는 점을 확인했다.

#### 해결 방법 
서버리스 환경에서의 안정성과 연결 효율을 고려해 Supabase를 사용해 원격 DB를 구성했다. 

Supabase에서 제공하는 DB URL을 Vercel 환경 변수로 등록해 사용했다.

#### 결과
배포 환경에서도 회원가입과 로그인 기능이 정상 동작했으며,
로그인 기반 좋아요 기능까지 문제없이 작동하는 것을 확인했다.

## 실행 방법

### 1. 프로젝트 클론
```
git clone https://github.com/kokiku1700/movie-search.git
cd movie-search
```
### 2. 패키지 설치
```
npm install
```
### 3. 환경 변수 설정
NEXT_PUBLIC_TMDB_ACCESS_TOKEN=

POSTGRES_HOST=

POSTGRES_PORT=

POSTGRES_DATABASE=

POSTGRES_USERNAME=

POSTGRES_PW=

#### 4. 개발 서버 실행
```
npm run dev
```
http://localhost:3000

#### 5. 프로덕션 빌드
```
npm run build

npm start
```

## 회고
이번 프로젝트는 사용한 대부분의 기술이 처음이라는 전제에서 시작했다. 

각 기술을 깊이 있게 숙달하는 것보다는 각 기술이 어떤 역할을 하고 어떤 특성을 가지는지 이해한 상태로 실제 서비스에 적용해보는 것을 목표로 진행했다.

사전에 개념 학습은 어느 정도 되어 있었지만 직접 프로젝트에 적용하는 과정에서는 예상보다 훨씬 많은 부분에서 막혔다.

사소해 보이는 문제 하나에도 원인을 찾는데 시간이 오래 걸렸고 그로 인해 프로젝트 전체 진행 속도가 느려졌다는 점은 분명한 사실이다.

하지만 그 과정 덕분에 "문서를 읽고 이해하는 것"과 "실제 서비스에 적용하는 것"의 차이를 체감할 수 있었다.

---

기술적인 측면에서는 Next.js, React Query, Tailwind CSS, PostgreSQL 등 처음 사용하는 도구들을 조합하며 각 기술이 왜 해당 위치에서 사용되는지 고민하려고 했다.

모든 기술을 완벽히 이해했다고 말할 수는 없지만 적어도 이 기술이 어떤 문제를 해결하기 위해 존재하는지에 대해서는 이전보다 분명한 기준을 가지게 되었다고 느낀다.

또한 기능 구현과 별개로 사용자 경험을 중요하게 생각하며 개발했다.

좋아요와 같은 인터랙션에서는 체감 속도에 민감하게 반응했고 실제 배포 환경에서 발생한 반응 속도 문제를 직접 경험하며 개발 환경과 운영 환경의 차이에 대해서도 배울 수 있었다.

---

배포 역시 이번 프로젝트에서 처음 경험한 과정이었다.

빌드, 환경 변수 설정, 배포 후 오류 수정까지 전 과정을 직접 겪으면서 "코드가 동작하는 것"과 "서비스로 제공되는 것"은 다르다는 점을 실감했다.

이 경험은 이후 프로젝트를 진행할 때 큰 자산이 될 것이라고 생각한다.

---

아쉬운 점도 분명히 존재한다.

회원가입과 로그인 기능을 프로젝트의 주 기능이 아니라는 이유로 최소한의 형태로만 구현했는데 프로젝트를 마무리한 시점에서 돌아보니 이 부분을 조금 더 깊이 있게 다뤄보지 못한 점이 아쉽게 느껴졌다.

이러한 아쉬움 때문에 다음 프로젝트에서는 단순한 인증 구현을 넘어 회원가입과 로그인 흐름 자체에 더 집중하고 보안과 사용자 경험을 함께 고려한 기능을 만들어 보고 싶다.

이번 프로젝트는 "완성도 높은 서비스"라기보다는 **여러 기술을 처음으로 연결해 하나의 서비스로 끝까지 만들어본 경험**이라는 점에서 개인적으로 의미가 크다.
